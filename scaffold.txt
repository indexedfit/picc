/*
================================================================================
📂  picc.fit – Minimal yet robust local‑first photo gallery (initial scaffold)
================================================================================

This single file lists **all** project files in a "virtual repo" format so you can
copy‑paste or split them as needed.  Each section starts with a comment header
`// FILE: <path>` – nothing else is required for Vite to pick things up.

Goals of this first iteration
-----------------------------
1. 🔨  **Scaffold** – Vite + React + TypeScript project that boots instantly on web & mobile.
2. 🗂  **Albums & All Pictures** primitives (local only).
3. 📦  **OPFS pipeline** – concurrent upload → CID multihash → store binary & thumb files via `opfs-tools`.
4. 🔄  **Yjs metadata doc** persisted to IndexedDB; ready for P2P sync later.
5. 💬  **Chat & activity log placeholders** – structure only, no UI yet.
6. 🗜  **Thumbnail generation** in an `UploadWorker` using off‑screen canvas.

Future features (links, sharing, presence, permissioning, etc.) are stubbed with
TODOs.  This keeps the code surface small yet extensible.

════════════════════════════════════════════════════════════════════════════════
*/

// -----------------------------------------------------------------------------
// FILE: package.json
// -----------------------------------------------------------------------------
{
  "name": "picc.fit",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "multiformats": "^11.0.2",
    "opfs-tools": "^0.6.2",
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "y-indexeddb": "^13.6.9",
    "yjs": "^13.6.12"
  },
  "devDependencies": {
    "@types/react": "^18.2.26",
    "@types/react-dom": "^18.2.12",
    "typescript": "^5.4.5",
    "vite": "^5.0.12"
  }
}

// -----------------------------------------------------------------------------
// FILE: vite.config.ts
// -----------------------------------------------------------------------------
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  build: {
    target: 'esnext', // OPFS & Wasm require modern browsers
  },
});

// -----------------------------------------------------------------------------
// FILE: index.html
// -----------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>picc.fit</title>
    <style>
      :root {
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        background: #f6f7f8;
        color: #111;
      }
      body, html { margin: 0; height: 100%; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

// -----------------------------------------------------------------------------
// FILE: src/main.tsx
// -----------------------------------------------------------------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// -----------------------------------------------------------------------------
// FILE: src/App.tsx
// -----------------------------------------------------------------------------
import React from 'react';
import { AlbumGrid } from './components/AlbumGrid';
import { UploadButton } from './components/UploadButton';
import { useAlbumDoc } from './yjs/album';

export default function App() {
  // We keep a single Y.Doc for now; future: multi‑album docs / subdocs.
  const { album } = useAlbumDoc('all-pictures');

  return (
    <div className="min-h-screen flex flex-col">
      <header className="p-4 border-b bg-white sticky top-0 z-10 flex items-center justify-between">
        <h1 className="text-xl">📸 picc.fit</h1>
        <UploadButton album={album} />
      </header>
      <main className="flex-1 overflow-y-auto p-4">
        <AlbumGrid album={album} />
      </main>
    </div>
  );
}

// -----------------------------------------------------------------------------
// FILE: src/types.ts
// -----------------------------------------------------------------------------
export interface PicMeta {
  cid: string;      // Multibase‑encoded CID (e.g. "bafy…")
  name: string;     // Original filename (can be edited later)
  type: string;     // MIME type
  ts: number;       // Unix epoch ms when added
  w?: number;       // width (filled after thumb gen)
  h?: number;       // height
}

// -----------------------------------------------------------------------------
// FILE: src/utils/hash.ts
// -----------------------------------------------------------------------------
/*
 * Streaming SHA‑256 → CID v1 util.
 * For large files we could use WASM sha2; here we buffer because uploads are
 * browser‑selected & usually photo‑sized.  Replace with streaming worker later.
 */
import { CID } from 'multiformats/cid';
import { sha256 } from 'multiformats/hashes/sha2';
import { base32 } from 'multiformats/bases/base32';

export async function fileToCid(file: Blob): Promise<string> {
  const buf = new Uint8Array(await file.arrayBuffer());
  const hash = await sha256.digest(buf);
  /*
   * `0x55` = raw binary content (multicodec code for raw) – OK for images/videos
   * You may choose dag‑pb or others later.
   */
  const cid = CID.create(1, 0x55, hash).toString(base32.encoder);
  return cid;
}

// -----------------------------------------------------------------------------
// FILE: src/utils/opfs.ts
// -----------------------------------------------------------------------------
import { write, file as otFile, dir } from 'opfs-tools';

const PICTURES_DIR = '/pictures';
const THUMBS_DIR = '/thumbs';

/** Ensure required directories exist */
export async function ensureDirs() {
  await Promise.all([dir(PICTURES_DIR).create(), dir(THUMBS_DIR).create()]);
}

/** Write content to OPFS by CID and return its OTFile handle */
export async function savePicture(cid: string, blob: Blob) {
  await ensureDirs();
  const targetPath = `${PICTURES_DIR}/${cid}`;
  await write(targetPath, blob, { overwrite: false });
  return otFile(targetPath);
}

export async function saveThumbnail(cid: string, blob: Blob) {
  await ensureDirs();
  await write(`${THUMBS_DIR}/${cid}.jpg`, blob, { overwrite: true });
}

export async function pictureExists(cid: string) {
  return otFile(`${PICTURES_DIR}/${cid}`).exists();
}

export async function thumbUrl(cid: string) {
  const exists = await otFile(`${THUMBS_DIR}/${cid}.jpg`).exists();
  if (!exists) return null;
  const f = await otFile(`${THUMBS_DIR}/${cid}.jpg`).getOriginFile();
  return f ? URL.createObjectURL(f) : null;
}

// -----------------------------------------------------------------------------
// FILE: src/workers/UploadWorker.ts
// -----------------------------------------------------------------------------
/* eslint-disable no-restricted-globals */
import { fileToCid } from '../utils/hash';
import { savePicture, saveThumbnail } from '../utils/opfs';
import type { PicMeta } from '../types';

interface UploadMsg {
  file: File;
}

self.onmessage = async (ev: MessageEvent<UploadMsg>) => {
  const { file } = ev.data;
  const cid = await fileToCid(file);
  const exists = await savePicture(cid, file); // skip if exists? – TODO

  // Generate thumbnail (simple cover 256px)
  const img = await createImageBitmap(file);
  const size = 256;
  const canvas = new OffscreenCanvas(size, size);
  const ctx = canvas.getContext('2d')!;
  // Fit image – keep aspect ratio, letterbox with white
  const ratio = Math.min(size / img.width, size / img.height);
  const w = img.width * ratio;
  const h = img.height * ratio;
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, size, size);
  ctx.drawImage(img, (size - w) / 2, (size - h) / 2, w, h);
  const blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });
  await saveThumbnail(cid, blob);

  const meta: PicMeta = {
    cid,
    name: file.name,
    type: file.type,
    ts: Date.now(),
    w: img.width,
    h: img.height,
  };

  // Send meta back to main thread
  postMessage(meta);
};

// -----------------------------------------------------------------------------
// FILE: src/yjs/album.ts
// -----------------------------------------------------------------------------
import * as Y from 'yjs';
import { IndexeddbPersistence } from 'y-indexeddb';
import { useEffect, useMemo, useState } from 'react';
import type { PicMeta } from '../types';

export interface AlbumDoc {
  pics: Y.Array<PicMeta>; // ordered list of pictures
  chat: Y.Array<{ from: string; msg: string; ts: number }>;
  doc: Y.Doc;
}

/** Create/load a Y.Doc for an album; persist to IndexedDB. */
export function useAlbumDoc(name: string) {
  const [ready, setReady] = useState(false);

  const album = useMemo<AlbumDoc>(() => {
    const doc = new Y.Doc();
    // One top‑level map makes GC easy if we need sub‑docs later
    const pics = doc.getArray<PicMeta>('pics');
    const chat = doc.getArray('chat');

    // Temporary pubkey – will be replaced with WASM crypto keypair
    if (!localStorage.getItem('pubkey')) {
      localStorage.setItem('pubkey', crypto.randomUUID());
    }

    // Persist locally
    const persistence = new IndexeddbPersistence(`piccfit-${name}`, doc);
    persistence.once('synced', () => setReady(true));

    return { pics, chat, doc };
  }, [name]);

  return { album, ready } as const;
}

// -----------------------------------------------------------------------------
// FILE: src/components/UploadButton.tsx
// -----------------------------------------------------------------------------
import React, { useRef } from 'react';
import { UploadIcon } from 'lucide-react';
import type { AlbumDoc } from '../yjs/album';
import type { PicMeta } from '../types';

export function UploadButton({ album }: { album: AlbumDoc }) {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {
    const files = Array.from(e.target.files ?? []);
    if (!files.length) return;

    // Use a dedicated worker to avoid blocking UI
    const worker = new Worker(new URL('../workers/UploadWorker.ts', import.meta.url), {
      type: 'module',
    });

    worker.onmessage = (ev: MessageEvent<PicMeta>) => {
      album.doc.transact(() => {
        album.pics.push([ev.data]);
      });
    };

    files.forEach((f) => worker.postMessage({ file: f }));
    worker.onerror = console.error;
    e.target.value = '';
  };

  return (
    <>
      <input
        ref={inputRef}
        type="file"
        accept="image/*,video/*"
        multiple
        hidden
        onChange={handleChange}
      />
      <button
        onClick={() => inputRef.current?.click()}
        className="border px-3 py-1 rounded hover:bg-gray-100 active:scale-95 flex items-center gap-1"
      >
        <UploadIcon size={16} /> Upload
      </button>
    </>
  );
}

// -----------------------------------------------------------------------------
// FILE: src/components/AlbumGrid.tsx
// -----------------------------------------------------------------------------
import React, { useEffect, useState } from 'react';
import { thumbUrl } from '../utils/opfs';
import type { AlbumDoc } from '../yjs/album';
import type { PicMeta } from '../types';

export function AlbumGrid({ album }: { album: AlbumDoc }) {
  const [pics, setPics] = useState<PicMeta[]>(album.pics.toArray());

  useEffect(() => {
    const observer = (e: Y.YArrayEvent<PicMeta>) => {
      setPics(album.pics.toArray());
    };
    album.pics.observe(observer);
    return () => album.pics.unobserve(observer);
  }, [album]);

  return (
    <div
      className="grid gap-2"
      style={{ gridTemplateColumns: 'repeat(auto-fill, minmax(128px, 1fr))' }}
    >
      {pics.map((p) => (
        <Thumb key={p.cid} pic={p} />
      ))}
    </div>
  );
}

function Thumb({ pic }: { pic: PicMeta }) {
  const [url, setUrl] = useState<string | null>(null);
  useEffect(() => {
    thumbUrl(pic.cid).then(setUrl);
  }, [pic.cid]);

  return (
    <div className="aspect-square bg-gray-200 rounded overflow-hidden relative">
      {url && <img src={url} alt={pic.name} className="w-full h-full object-cover" />}
    </div>
  );
}

/*
================================================================================
📑  End of scaffold – happy hacking! ✨
================================================================================
*/

